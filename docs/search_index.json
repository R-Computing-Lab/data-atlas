[["index.html", "Data Atlas Abstract", " Data Atlas S. Mason Garrison 2024-06-23 Abstract The adage ‘A picture is worth a thousand words’ is just as applicable to Behavior Genetics as it is to journalism. In this talk, I delve into the rich diverse history of data visualization techniques in the field of behavior genetics, tracing advancements from Wright’s (Wright 1920) classic path diagram of guinea pigs to the contemporary usage of Manhattan plots. This survey sets the stage for the development of two resources aimed at bolstering the field’s visualization toolkit. The first, an atlas employing ‘ggplot2’ in R, aims to guide researchers in selecting the most appropriate visualization techniques for their data. The second, a proposed R package, seeks to facilitate the integration of ‘OpenMx’-compatible visualizations, streamlining the presentation of complex genetic analyses. Emphasizing practical advice, the talk will cover effective uses of path diagrams, family trees, and interaction visualizations, with the goal of improving clarity and interpretability of genetic data. This initiative aspires to democratize advanced data visualization tools, making them more accessible to the behavior genetics community and, in turn, amplifying the impact and reach of its research. "],["preface.html", "Preface How to use these notes", " Preface In the dynamic field of behavior genetics, the ability to visualize complex data clearly and effectively is not just a technical skill but a narrative art. This document, accompanying the talk on the historical and innovative approaches to data visualization in behavior genetics, introduces the fundamentals of employing ggplot2, a powerful and versatile package in R for creating quality graphics. ggplot2 is part of the tidyverse, an opinionated collection of R packages designed for data science that share an underlying design philosophy, grammar, and data structures. At the heart of ggplot2 is the concept of a layered grammar of graphics, which allows users to create graphics in a step-by-step, clear and logical way. This framework not only simplifies plotting complex data but also encourages a deeper understanding of the graphical representation itself—making it an ideal tool for behavior geneticists seeking to unvail the hidden stories within their data. The Data Atlas presented here is designed to serve as a practical guide through the landscape of data visualization techniques specific to the field of behavior genetics. It offers a curated selection of graphical methods that range from the foundational, such as Wright’s classic path diagrams, to the advanced, like the interaction visualizations and Manhattan plots, which have become indispensable in the modern geneticist’s toolkit. Further, this document and the accompanying talk address the development of an innovative R package tailored to integrate with OpenMx and BGmisic, projects aimed at facilitating advanced statistical modeling of complex genetic data. This package is proposed to enhance the ggplot2 environment, making it more conducive to the specialized needs of behavior genetics research—such as the visualization of path diagrams and family trees that are not only informative but are also aesthetically compelling. As we proceed, this introduction will delve into the specifics of ggplot2 usage in R, demonstrating how this tool can be adapted to meet the unique challenges of visualizing behavioral and genetic data. By bridging the gap between traditional methods and contemporary demands, the resources developed aim to democratize advanced data visualization tools, thereby expanding the accessibility and impact of behavior genetics research. How to use these notes To navigate these notes, use the table of contents on the left side of the screen. You can open or close the table of contents using the hamburger icon (horizontal bars) at the top of the document. Additionally, there are other icons at the top of the document for searching within the text, and for adjusting the size, font, or color scheme of the page. The document will be updated unpredictably. "],["attribution.html", "Attribution Major Attributions", " Attribution These notes lean heavily on other peoples’ materials and ideas. I have done my best to document the origin of the materials and ideas. In particular, I have noted people whose work has been a major contribution as well as those who have additional contributions. You can see specific changes by examining the edit history on the git repo Major Attributions Jenny Bryan’s (jennybryan.org) STAT 545 and Happy Git with R; Mason Garrison’s PSY 720 Data Science for Psychologists "],["license.html", "License", " License This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. This information is a human-readable summary of (and not a substitute for) the license. Please see https://creativecommons.org/licenses/by-sa/4.0/legalcode for the full legal text. You are free to: Share—copy and redistribute the material in any medium or format Remix—remix, transform, and build upon the material for any purpose, even commercially. The licensor cannot revoke these freedoms as long as you follow the license terms. Under the following terms: Attribution—You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use. ShareAlike—If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original. No additional restrictions—You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits. Notices: You do not have to comply with the license for elements of the material in the public domain or where your use is permitted by an applicable exception or limitation. No warranties are given. The license may not give you all of the permissions necessary for your intended use. For example, other rights such as publicity, privacy, or moral rights may limit how you use the material. "],["colophon.html", "Colophon", " Colophon These notes was written in bookdown inside RStudio. The website is hosted with github. The complete source is available from github. The book style was designed by Desirée De Leon. This version of the notes was built with: ## Finding R package dependencies ... Done! ## setting value ## version R version 4.4.1 (2024-06-14 ucrt) ## os Windows 11 x64 (build 22635) ## system x86_64, mingw32 ## ui RTerm ## language (EN) ## collate English_United States.utf8 ## ctype English_United States.utf8 ## tz America/New_York ## date 2024-06-23 ## pandoc 3.1.11 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown) Along with these packages: "],["crash-course-on-the-tidyverse.html", "1 Crash Course on the Tidyverse 1.1 What is the Tidyverse? 1.2 What’s the Difference between Base R and the Tidyverse?", " 1 Crash Course on the Tidyverse This chapter contains a brief introduction to the tidyverse package suite, which is a collection of R packages designed to make data manipulation and visualization easier and more intuitive. The tidyverse packages share a common philosophy and syntax, making it easy to learn and use them together. The resulting code is self-documenting, and thus easier to maintain, read, and share, making it ideal for data analysis and visualization. This crash course is extremely abridged. For a more in-depth treatment of the tidyverse, I recommend checking out my multimedia textbook Data Science for Psychologists and the R for Data Science book by Hadley Wickham and Garrett Grolemund. 1.1 What is the Tidyverse? The tidyverse is a collection of R packages that share a common philosophy and syntax. The packages are designed to work together to make data manipulation and visualization easier and more intuitive. The tidyverse includes some of the most popular and widely used R packages, such as ggplot2, dplyr, tidyr, and readr. These packages are built on the principles of tidy data, which is a standard way of organizing data that makes it easy to work with. 1.1.1 Tidy data Happy families are all alike; every unhappy family is unhappy in its own way. Leo Tolstoy Tidy data has the following properties: Each variable forms a column. Each observation forms a row. Each type of observational unit forms a table. Tidy data is easy to manipulate, visualize, and model, and it is the preferred format for data analysis in the tidyverse. The tidyverse packages are designed to work with tidy data, and they provide tools and functions that make it easy to transform and visualize data in this format. Untidy data does not have these properties, and it can be more difficult to work with. 1.2 What’s the Difference between Base R and the Tidyverse? There are some key differences between base R and the tidyverse. I like to think of them as different dialects. (I’ll often say I was raised in based R.) Base R is powerful and flexible, but it can be difficult to learn and use, especially for beginners. The tidyverse, on the other hand, is designed to be easy to learn and use, with a consistent syntax and a focus on data manipulation and visualization. The tidyverse also includes a number of functions and tools that make common data analysis tasks easier and more intuitive. Someone who is familiar with base R might notice several key differences when they’re introduced to the tidyverse. In my experience the main differences are: Syntax and Readability: The tidyverse uses a more consistent and readable syntax that emphasizes clarity and the flow of operations. For example, it leverages the %&gt;% pipe operator from the magrittr package extensively, allowing for code to be written in a way that is easy to read from left to right, much like a series of steps. Pipe operators are used in many programming languages to chain together operations. In R, the pipe operator %&gt;% is used to pass the output of one function to the next function as the first argument. This allows you to write code in a way that is easy to read and understand, with each step of the data analysis process clearly laid out. To use the pipe operator, you simply place it between two functions, like this: output &lt;- function1(input) %&gt;% function2() When these pipes are chained together, they create a clear and readable sequence of operations that can be easily understood by others. This makes it easier to write and maintain code, and it can also help you avoid errors by breaking down complex tasks into smaller, more manageable steps. Here’s an example of how the pipe operator can be used to chain together a series of data manipulation operations in the tidyverse: data %&gt;% filter(condition) %&gt;% select(variables) %&gt;% mutate(new_variable = expression) %&gt;% group_by(grouping_variable) %&gt;% summarize(summary_statistic) Much of the rest of the differences are which functions are used for common tasks. For example: - Data Manipulation: While base R uses functions like subset, merge, and apply, the tidyverse offers dplyr which provides functions like filter, select, mutate, summarize, and join. These functions are often seen as more intuitive and powerful for data manipulation tasks. Data Import and Tidying: Base R provides functions like read.table and read.csv for data import, and various base functions for data cleaning and reshaping (e.g., reshape, aggregate). The tidyverse, on the other hand, has readr for reading data and tidyr for tidying data. The tidying functions, such as gather and spread (now evolved into pivot_longer and pivot_wider), focus on the concept of “tidy data” where each variable forms a column, each observation forms a row, and each type of observational unit forms a table. Handling Factor Variables: In base R, factors are often automatically created when importing data which can lead to unexpected behaviors if not properly managed. The tidyverse’s forcats package provides tools that make factor management more explicit and less error-prone. Functional Programming: Base R uses apply functions like lapply and sapply for operations on lists or vectors. The tidyverse introduces purrr which provides a much needed enhancment for R functional programming with a consistent and coherent set of tools for working with functions and vectors. Other differences are more subtle but can have a big impact on the user experience, such as how graphics can be handled and how data types are stored: - Visualization: Base R uses traditional plotting functions such as plot and hist. The tidyverse offers ggplot2, based on the grammar of graphics, which allows for building plots layer by layer and integrates well with the rest of the tidyverse data manipulation packages. Data Types and Storage: The tidyverse introduces tibbles via the tibble package, which are modern reimaginings of data frames. Tibbles are data frames but slightly tweaked to work better in the tidyverse; for example, they never change a variable’s type when adding rows, don’t use row names, and provide a better print method that shows only the first 10 rows and all columns that fit on the screen. Overall, the tidyverse provides a coherent system of packages that facilitate data manipulation, analysis, and visualization in a way that is generally considered to be more user-friendly, especially for those new to R or programming in general. However, this can also lead to a bit of a learning curve for those deeply entrenched in base R. "],["introduction-to-ggplot2.html", "2 Introduction to ggplot2 2.1 Understanding ggplot2’s Grammar of Graphics 2.2 Case Study: Visualizing Twin Data", " 2 Introduction to ggplot2 In this chapter, we explore the power of ggplot2 within the tidyverse package suite for creating compelling visual representations of twin studies in behavior genetics. ggplot2’s layer-oriented approach to building data visualizations allows researchers to intuitively map out the complexities inherent in twin data, providing insights that are crucial for both hypothesis testing and exploratory data analysis. 2.1 Understanding ggplot2’s Grammar of Graphics ggplot2 is a powerful data visualization package in R that is part of the tidyverse suite of packages. It is based on the grammar of graphics, a coherent system for describing and building visualizations. The grammar of graphics is based on the idea that a plot can be decomposed into a set of independent components, such as data, aesthetics, and geoms (geometric objects). By combining these components, ggplot2 allows for the creation of complex and informative visualizations that can be easily customized and extended. The structure of the code for plots can be summarized as follows: ggplot(data = [[dataset]], mapping = aes(x = [[x-variable]], y = [[y-variable]])) + geom_xxx() + other options Each component of the plot is added in layers. The ggplot() function initializes the plot, aes() specifies the aesthetic mappings (how variables are mapped to visual properties), and geom_xxx() adds a geometric object (points, lines, bars, etc.) to the plot. Additional layers can be added to further customize the plot, such as labels, titles, and themes. We’ll dive into these soon enough, but first, let’s walk through a simple example to illustrate the basic structure of a ggplot2 plot. 2.2 Case Study: Visualizing Twin Data To make this more concrete, let’s consider an example using twin data on height from the OpenMX package, which is in the twinData data. These 3,808 pairs of twins are from the Australian National Health and Medical Research Council Twin Registry. The dataset contains information on the height, weight, and body mass index (BMI) of twins, along with their zygosity and other demographic information. library(tidyverse) # Load the tidyverse packages library(OpenMx) # Load the OpenMx package library(BGmisc) # Load the BGmisc package library(conflicted) # to handle conflicts conflicted::conflicts_prefer(OpenMx::vech,dplyr::filter) # Resolve conflicts data(twinData) glimpse(twinData) #&gt; Rows: 3,808 #&gt; Columns: 16 #&gt; $ fam &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18… #&gt; $ age &lt;int&gt; 21, 24, 21, 21, 19, 26, 23, 29, 24, 28, 29, 19, 23, 22, 23, 2… #&gt; $ zyg &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1… #&gt; $ part &lt;int&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2… #&gt; $ wt1 &lt;int&gt; 58, 54, 55, 66, 50, 60, 65, 40, 60, 76, 48, 70, 51, 53, 58, 4… #&gt; $ wt2 &lt;int&gt; 57, 53, 50, 76, 48, 60, 65, 39, 57, 64, 51, 67, 51, 55, 57, 5… #&gt; $ ht1 &lt;dbl&gt; 1.70, 1.63, 1.65, 1.57, 1.61, 1.60, 1.75, 1.56, 1.76, 1.70, 1… #&gt; $ ht2 &lt;dbl&gt; 1.70, 1.63, 1.68, 1.65, 1.63, 1.57, 1.77, 1.53, 1.77, 1.73, 1… #&gt; $ htwt1 &lt;dbl&gt; 20.1, 20.3, 20.2, 26.8, 19.3, 23.4, 21.2, 16.4, 19.4, 26.3, 2… #&gt; $ htwt2 &lt;dbl&gt; 19.7, 19.9, 17.7, 27.9, 18.1, 24.3, 20.7, 16.7, 18.2, 21.4, 2… #&gt; $ bmi1 &lt;dbl&gt; 21.0, 21.1, 21.0, 23.0, 20.7, 22.1, 21.4, 19.6, 20.7, 22.9, 2… #&gt; $ bmi2 &lt;dbl&gt; 20.9, 21.0, 20.1, 23.3, 20.3, 22.3, 21.2, 19.7, 20.3, 21.4, 2… #&gt; $ cohort &lt;chr&gt; &quot;younger&quot;, &quot;younger&quot;, &quot;younger&quot;, &quot;younger&quot;, &quot;younger&quot;, &quot;young… #&gt; $ zygosity &lt;fct&gt; MZFF, MZFF, MZFF, MZFF, MZFF, MZFF, MZFF, MZFF, MZFF, MZFF, M… #&gt; $ age1 &lt;int&gt; 21, 24, 21, 21, 19, 26, 23, 29, 24, 28, 29, 19, 23, 22, 23, 2… #&gt; $ age2 &lt;int&gt; 21, 24, 21, 21, 19, 26, 23, 29, 24, 28, 29, 19, 23, 22, 23, 2… I’m going to tidy up the data a bit by renaming the columns and removing some unnecessary columns. I’ll also filter out any rows with missing values in the height columns. I’ve also added a column to represent the sex of the twins and their zygosity. twinData_cleaned &lt;- twinData %&gt;% rename( # Rename columns family = fam, weight_t1 = wt1, weight_t2 = wt2, height_t1 = ht1, height_t2 = ht2, bmi_t1 = bmi1, bmi_t2 = bmi2, age_t1 = age1, age_t2 = age2, heightweight_t1 = htwt1, heightweight_t2 = htwt2) %&gt;% select(-c(# Remove unnecessary columns part, zyg, age_t1, age_t2)) %&gt;% filter(# Remove rows with missing values !is.na(height_t1), !is.na(height_t2)) %&gt;% mutate( # Create new columns sex = case_when(zygosity %in% c(&quot;MZFF&quot;,&quot;DZFF&quot;) ~ &quot;F&quot;, zygosity %in% c(&quot;MZMM&quot;,&quot;DZMM&quot;) ~ &quot;M&quot;, TRUE ~ &quot;OS&quot;), zyg = case_when(zygosity %in% c(&quot;MZFF&quot;,&quot;MZMM&quot;) ~ &quot;MZ&quot;, zygosity %in% c(&quot;DZFF&quot;,&quot;DZMM&quot;,&quot;DZOS&quot;) ~ &quot;DZ&quot;, TRUE ~ NA_character_ )) glimpse(twinData_cleaned) #&gt; Rows: 3,667 #&gt; Columns: 14 #&gt; $ family &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,… #&gt; $ age &lt;int&gt; 21, 24, 21, 21, 19, 26, 23, 29, 24, 28, 29, 19, 23, 22… #&gt; $ weight_t1 &lt;int&gt; 58, 54, 55, 66, 50, 60, 65, 40, 60, 76, 48, 70, 51, 53… #&gt; $ weight_t2 &lt;int&gt; 57, 53, 50, 76, 48, 60, 65, 39, 57, 64, 51, 67, 51, 55… #&gt; $ height_t1 &lt;dbl&gt; 1.70, 1.63, 1.65, 1.57, 1.61, 1.60, 1.75, 1.56, 1.76, … #&gt; $ height_t2 &lt;dbl&gt; 1.70, 1.63, 1.68, 1.65, 1.63, 1.57, 1.77, 1.53, 1.77, … #&gt; $ heightweight_t1 &lt;dbl&gt; 20.1, 20.3, 20.2, 26.8, 19.3, 23.4, 21.2, 16.4, 19.4, … #&gt; $ heightweight_t2 &lt;dbl&gt; 19.7, 19.9, 17.7, 27.9, 18.1, 24.3, 20.7, 16.7, 18.2, … #&gt; $ bmi_t1 &lt;dbl&gt; 21.0, 21.1, 21.0, 23.0, 20.7, 22.1, 21.4, 19.6, 20.7, … #&gt; $ bmi_t2 &lt;dbl&gt; 20.9, 21.0, 20.1, 23.3, 20.3, 22.3, 21.2, 19.7, 20.3, … #&gt; $ cohort &lt;chr&gt; &quot;younger&quot;, &quot;younger&quot;, &quot;younger&quot;, &quot;younger&quot;, &quot;younger&quot;,… #&gt; $ zygosity &lt;fct&gt; MZFF, MZFF, MZFF, MZFF, MZFF, MZFF, MZFF, MZFF, MZFF, … #&gt; $ sex &lt;chr&gt; &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;,… #&gt; $ zyg &lt;chr&gt; &quot;MZ&quot;, &quot;MZ&quot;, &quot;MZ&quot;, &quot;MZ&quot;, &quot;MZ&quot;, &quot;MZ&quot;, &quot;MZ&quot;, &quot;MZ&quot;, &quot;MZ&quot;, … The code structure for our plot would look like this: ggplot(data = twinData_cleaned, mapping = aes(x = height_t1, y = height_t2)) + geom_point() + labs(title = &quot;Height Comparison between Twins&quot;) It would produce a scatter plot comparing the height of twins with the height of twin 1 on the x-axis and the height of twin 2 on the y-axis. 2.2.1 Key Components of a ggplot2 Plot The code above demonstrates the basic structure of a ggplot2 plot. To break down the key components of the plot you can press the left and right arrows on your keyboard to navigate through the slides below. Or if you prefer, you can click on the slide to advance to the next one. Below the slides you’ll find the same content in a more traditional format. #&gt; Error in df_url$link: $ operator is invalid for atomic vectors 2.2.1.1 Plot Breakdown Start with the twinData_cleaned data frame ggplot(data = twinData_cleaned) #&lt;&lt; Start with the twinData_cleaned data frame, map twin 1’s height to the x-axis ggplot(data = twinData_cleaned, mapping = aes(x = height_t1)) #&lt;&lt; Start with the twinData_cleaned data frame, map twin 1’s height to the x-axis, and and map twin 2’s height to the y-axis. ggplot(data = twinData_cleaned, mapping = aes( x = height_t1, y = height_t2)) #&lt;&lt; Start with the twinData_cleaned data frame, map twin 1’s height to the x-axis, and and map twin 2’s height to the y-axis. Represent each observation with a point ggplot(data = twinData_cleaned, mapping = aes( x = height_t1, y = height_t2)) + geom_point() #&lt;&lt; Start with the twinData_cleaned data frame, map twin 1’s height to the x-axis, and and map twin 2’s height to the y-axis. Represent each observation with a point, and map zygosity to the color of each point. ggplot(data = twinData_cleaned, mapping = aes( x = height_t1, y = height_t2, color = zyg)) + #&lt;&lt; geom_point() Start with the twinData_cleaned data frame, map twin 1’s height to the x-axis, and and map twin 2’s height to the y-axis. Represent each observation with a point, and map zygosity to the color of each point. Title the plot “Height Comparison between Twins” ggplot(data = twinData_cleaned, mapping = aes( x = height_t1, y = height_t2, color = zyg)) + geom_point() + labs(title = &quot;Height Comparison between Twins&quot;) #&lt;&lt; Start with the twinData_cleaned data frame, map twin 1’s height to the x-axis, and and map twin 2’s height to the y-axis. Represent each observation with a point, and map zygosity to the color of each point. Title the plot “Height Comparison between Twins”, add the subtitle “by zygosity” ggplot(data = twinData_cleaned, mapping = aes( x = height_t1, y = height_t2, color = zyg)) + geom_point() + labs(title = &quot;Height Comparison between Twins&quot;, subtitle = &quot;by zygosity&quot;) #&lt;&lt; Start with the twinData_cleaned data frame, map twin 1’s height to the x-axis, and and map twin 2’s height to the y-axis. Represent each observation with a point, and map zygosity to the color of each point. Title the plot “Height Comparison between Twins”, add the subtitle “by zygosity”, label the x and y axes as “Height of Twin 1 (m)” and “Height of Twin 2 (m)”, respectively ggplot(data = twinData_cleaned, mapping = aes( x = height_t1, y = height_t2, color = zyg)) + geom_point() + labs(title = &quot;Height Comparison between Twins&quot;, subtitle = &quot;by zygosity&quot;, x = &quot;Height of Twin 1 (m)&quot;, y = &quot;Height of Twin 2 (m)&quot;) #&lt;&lt; Start with the twinData_cleaned data frame, map twin 1’s height to the x-axis, and and map twin 2’s height to the y-axis. Represent each observation with a point, and map zygosity to the color of each point. Title the plot “Height Comparison between Twins”, add the subtitle “by zygosity”, label the x and y axes as “Height of Twin 1 (m)” and “Height of Twin 2 (m)”, respectively , label the legend “Zygosity” ggplot(data = twinData_cleaned, mapping = aes( x = height_t1, y = height_t2, color = zyg)) + geom_point() + labs(title = &quot;Height Comparison between Twins&quot;, subtitle = &quot;by zygosity&quot;, x = &quot;Height of Twin 1 (m)&quot;, y = &quot;Height of Twin 2 (m)&quot;, color = &quot;Zygosity&quot;) #&lt;&lt; Start with the twinData_cleaned data frame, map twin 1’s height to the x-axis, and and map twin 2’s height to the y-axis. Represent each observation with a point, and map zygosity to the color of each point. Title the plot “Height Comparison between Twins”, add the subtitle “by zygosity”, label the x and y axes as “Height of Twin 1 (m)” and “Height of Twin 2 (m)”, respectively , label the legend “Zygosity”, and add a caption for the data source. ggplot(data = twinData_cleaned, mapping = aes( x = height_t1, y = height_t2, color = zyg)) + geom_point() + labs(title = &quot;Height Comparison between Twins&quot;, subtitle = &quot;by zygosity&quot;, x = &quot;Height of Twin 1 (m)&quot;, y = &quot;Height of Twin 2 (m)&quot;, color = &quot;Zygosity&quot;, caption = &quot;Source: Australian National Health and Medical Research Council Twin Registry / OpenMx package&quot;) #&lt;&lt; Start with the twinData_cleaned data frame, map twin 1’s height to the x-axis, and and map twin 2’s height to the y-axis. Represent each observation with a point, and map zygosity to the color of each point. Title the plot “Height Comparison between Twins”, add the subtitle “by zygosity”, label the x and y axes as “Height of Twin 1 (m)” and “Height of Twin 2 (m)”, respectively , label the legend “Zygosity”, and add a caption for the data source. Finally, use a discrete color scale that is designed to be perceived by viewers with common forms of color blindness. ggplot(data = twinData_cleaned, mapping = aes( x = height_t1, y = height_t2, color = zyg)) + geom_point() + labs(title = &quot;Height Comparison between Twins&quot;, subtitle = &quot;by zygosity&quot;, x = &quot;Height of Twin 1 (m)&quot;, y = &quot;Height of Twin 2 (m)&quot;, color = &quot;Zygosity&quot;, caption = &quot;Source: Australian National Health and Medical Research Council Twin Registry / OpenMx package&quot;) + scale_color_viridis_d() #&lt;&lt; "],["wide-form-data.html", "3 Wide Form Data 3.1 Import Data 3.2 Data Structure 3.3 Summary Statistics (Wide Form)", " 3 Wide Form Data Wide form data is a common way to store data, especially when it comes from family data. surveys or experiments where each family has multiple members (twins, siblings etc) In this form, each row represents a family, and each column represents a variable or measurement for a specific family member. This format is easy to understand and work with, but it can be challenging for certain types of analyses or visualizations. In this section, demonstrate straightforward ways to import, summarize, and visualize wide form data using the twinData dataset from the OpenMx package. 3.1 Import Data We’re going to use the twinData dataset from the OpenMx package. This dataset contains 3,808 pairs of Australian twins on the 12 variables. library(tidyverse) library(NlsyLinks) library(discord) library(BGmisc) library(OpenMx) library(conflicted) # to handle conflicts conflicted::conflicts_prefer(OpenMx::vech,dplyr::filter) # Resolve conflicts data(twinData) df_wide &lt;- twinData 3.2 Data Structure Let’s take a look at the structure of the dataset using the class and glimpse functions. class(df_wide) ## [1] &quot;data.frame&quot; glimpse(df_wide) ## Rows: 3,808 ## Columns: 16 ## $ fam &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18… ## $ age &lt;int&gt; 21, 24, 21, 21, 19, 26, 23, 29, 24, 28, 29, 19, 23, 22, 23, 2… ## $ zyg &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1… ## $ part &lt;int&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2… ## $ wt1 &lt;int&gt; 58, 54, 55, 66, 50, 60, 65, 40, 60, 76, 48, 70, 51, 53, 58, 4… ## $ wt2 &lt;int&gt; 57, 53, 50, 76, 48, 60, 65, 39, 57, 64, 51, 67, 51, 55, 57, 5… ## $ ht1 &lt;dbl&gt; 1.7000, 1.6299, 1.6499, 1.5698, 1.6099, 1.5999, 1.7500, 1.559… ## $ ht2 &lt;dbl&gt; 1.7000, 1.6299, 1.6799, 1.6499, 1.6299, 1.5698, 1.7698, 1.529… ## $ htwt1 &lt;dbl&gt; 20.0692, 20.3244, 20.2020, 26.7759, 19.2894, 23.4375, 21.2245… ## $ htwt2 &lt;dbl&gt; 19.7232, 19.9481, 17.7154, 27.9155, 18.0662, 24.3418, 20.7476… ## $ bmi1 &lt;dbl&gt; 20.9943, 21.0828, 21.0405, 23.0125, 20.7169, 22.0804, 21.3861… ## $ bmi2 &lt;dbl&gt; 20.8726, 20.9519, 20.1210, 23.3043, 20.2583, 22.3454, 21.2270… ## $ cohort &lt;chr&gt; &quot;younger&quot;, &quot;younger&quot;, &quot;younger&quot;, &quot;younger&quot;, &quot;younger&quot;, &quot;young… ## $ zygosity &lt;fct&gt; MZFF, MZFF, MZFF, MZFF, MZFF, MZFF, MZFF, MZFF, MZFF, MZFF, M… ## $ age1 &lt;int&gt; 21, 24, 21, 21, 19, 26, 23, 29, 24, 28, 29, 19, 23, 22, 23, 2… ## $ age2 &lt;int&gt; 21, 24, 21, 21, 19, 26, 23, 29, 24, 28, 29, 19, 23, 22, 23, 2… As we can see, the dataset contains 3808 observations of 16 variables. Most of these variables include two entries, one for twin 1 and one for twin 2. The zygosity variable indicates the zygosity of the twins, while other variables represent different measurements or characteristics of the twins, and denote which twin they refer to by the suffixes 1 and 2. We can also see that the dataset contains a mix of numeric and character variables. To improve the readability of the dataset, we are going to split the information from the zygosity variable into two separate variables: sex and zyg. This will make it easier to analyze and visualize the data later on. df_wide &lt;- df_wide %&gt;% mutate(sex = case_when(zygosity %in% c(&quot;MZFF&quot;,&quot;DZFF&quot;) ~ &quot;F&quot;, zygosity %in% c(&quot;MZMM&quot;,&quot;DZMM&quot;) ~ &quot;M&quot;, TRUE ~ &quot;OS&quot;), zyg = case_when(zygosity %in% c(&quot;MZFF&quot;,&quot;MZMM&quot;) ~ &quot;MZ&quot;, zygosity %in% c(&quot;DZFF&quot;,&quot;DZMM&quot;,&quot;DZOS&quot;) ~ &quot;DZ&quot;, TRUE ~ NA_character_ )) 3.2.1 Annotated explainaton for the code snippet above: The provided R code uses the tidyverse package’s dplyr library to manipulate a data frame named df_wide. The mutate function is used to create new variables or modify existing ones within the data frame. (In this case it is creating sex and over writing zyg. Here’s an annotation of what each part of the code is doing: Data Frame Assignment: df_wide &lt;- df_wide %&gt;% This line indicates that we are taking the existing data frame df_wide and using the %&gt;% operator (pipe) to pass it through additional functions. The result will be stored back into the df_wide. Mutate Function: mutate(sex = ..., zyg = ...) The mutate function is used to add new columns to the data frame or change existing ones. In this case, one new column sex is being added and the existing column zyg is being modified. Creating sex Column: sex = case_when(...) creates a new column named sex based on conditions applied to the zygosity column. The case_when function is similar to a series of if-else statements. For each row, it checks the conditions in order and assigns a value to sex based on the first matching condition. Conditions for sex Column: zygosity %in% c(\"MZFF\",\"DZFF\") ~ \"F\" condition checks if the zygosity value is either “MZFF” or “DZFF”. If true, “F” (Female) is assigned to the sex column. zygosity %in% c(\"MZMM\",\"DZMM\") ~ \"M\" checks if the zygosity value is either “MZMM” or “DZMM”. If true, “M” (Male) is assigned to the sex column. TRUE ~ \"OS\" is a catch-all condition that assigns “OS” (Other or Unknown sex) if none of the above conditions are met. Creating zyg Column: Similar to the sex column, zyg = case_when(...) overwrites an old column zyg that categorizes zygosity into broader categories. Conditions for zyg Column: zygosity %in% c(\"MZFF\",\"MZMM\") ~ \"MZ\" checks if zygosity is either “MZFF” or “MZMM” and assigns “MZ” (Monozygotic) indicating identical twins. zygosity %in% c(\"DZFF\",\"DZMM\",\"DZOS\") ~ \"DZ\" checks if zygosity falls into any of “DZFF”, “DZMM”, or “DZOS”, assigning “DZ” (Dizygotic) indicating fraternal twins. TRUE ~ NA_character_ assigns a missing value (NA) if none of the above conditions are met, possibly used to handle cases where zygosity data is not clearly defined or is missing. This code effectively categorizes individuals in the dataset based on zygosity into more workable groups for sex and twin status, which can (and will) be useful for further analysis and visualization. 3.3 Summary Statistics (Wide Form) Let’s calculate summary statistics for numeric variables across the full sample. This will provide a quick overview of central tendencies and variability in the dataset. When working with wide form data, it is often helpful to start with summarizing by the data structure you already have. In this case, we will calculate summary statistics by specific twin (twin 1 or twin 2). 3.3.1 Numeric Variables Calculate summary statistics for numeric variables across the full sample. This helps provide a quick overview of central tendencies and variability. # Calculate summary statistics for numeric variables across the full sample summary_stats &lt;- df_wide %&gt;% summarise(across(where(is.numeric), list( mean = ~mean(., na.rm = TRUE), sd = ~sd(., na.rm = TRUE), median = ~median(., na.rm = TRUE), min = ~min(., na.rm = TRUE), max = ~max(., na.rm = TRUE), IQR = ~IQR(., na.rm = TRUE) ), .names = &quot;{col}_{fn}&quot;)) %&gt;% pivot_longer( cols = everything(), names_to = c(&quot;variable&quot;, &quot;statistic&quot;), names_sep = &quot;_&quot; ) %&gt;% pivot_wider( names_from = statistic, values_from = value ) summary_stats ## # A tibble: 13 × 7 ## variable mean sd median min max IQR ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 fam 1904. 1099. 1904. 1 3808 1904. ## 2 age 34.5 14.2 30 17 88 19 ## 3 part 1.93 0.265 2 0 2 0 ## 4 wt1 62.2 10.9 60 34 111 15 ## 5 wt2 65.6 12.2 65 35 127 16 ## 6 ht1 1.66 0.0896 1.65 1.34 1.98 0.130 ## 7 ht2 1.69 0.0990 1.7 1.40 1.99 0.140 ## 8 htwt1 22.5 3.16 21.9 13.3 41.9 3.84 ## 9 htwt2 22.8 3.19 22.3 14.2 46.2 3.78 ## 10 bmi1 21.7 0.940 21.6 18.1 26.1 1.21 ## 11 bmi2 21.8 0.939 21.7 18.6 26.8 1.18 ## 12 age1 34.5 14.2 30 17 88 19 ## 13 age2 34.5 14.2 30 17 88 19 As you can see in the table above, the summary statistics provide a quick overview of the central tendencies and variability in the dataset for numeric variables. The table includes the mean, standard deviation, median, minimum, maximum, and interquartile range (IQR) for each numeric variable. But they do so by the twin number, which is useful for our purposes, but… isn’t the only descriptive information we’ll need. We will need to calculate these statistics for the full sample, not by twin number. But we’ll still going to start with the twin number, and then we’ll calculate the summary statistics for the full sample. 3.3.2 Frequency Tables Create frequency tables for categorical variables like zygosity and sex, providing a clear picture of the distribution of these categories within the dataset. These numbers are easier to calculation when data are wide like this because we’re actually interested in the dyad, not the individual. # Counting &#39;zygosity&#39; and calculating percentages zygosity_summary &lt;- df_wide %&gt;% count(zyg, name = &quot;count&quot;) %&gt;% mutate(percentage = count / sum(count) * 100) %&gt;% rename(category = zyg) %&gt;% # Renaming the column for clarity mutate(variable = &quot;zygosity&quot;) # Adding a descriptor column for the variable # Counting &#39;sex&#39; and calculating percentages sex_summary &lt;- df_wide %&gt;% count(sex, name = &quot;count&quot;) %&gt;% mutate(percentage = count / sum(count) * 100) %&gt;% rename(category = sex) %&gt;% # Renaming the column for clarity mutate(variable = &quot;sex&quot;) # Adding a descriptor column for the variable # Combining both summaries into a single dataframe combined_summary &lt;- bind_rows(zygosity_summary, sex_summary) %&gt;% select(variable, category, everything()) # Reordering columns for clarity combined_summary ## variable category count percentage ## 1 zygosity DZ 2009 52.75735 ## 2 zygosity MZ 1799 47.24265 ## 3 sex F 1983 52.07458 ## 4 sex M 919 24.13340 ## 5 sex OS 906 23.79202 As you can see in the table above, the frequency tables provide a clear picture of the distribution of categories within the dataset for the zygosity and sex. Interestingly, there are many more same sex female twins, which make up 1983/3808 (52%) of the dataset. What if you want to examine these wideform by cohort? You can use the group_by function to group the data by cohort and then calculate the summary statistics for each cohort. library(tidyverse) # Grouping by &#39;cohort&#39; and calculating summary statistics for each group across values that are numeric df_summary &lt;- df_wide %&gt;% group_by(cohort) %&gt;% summarise(across(where(is.numeric), list( mean = ~mean(., na.rm = TRUE), sd = ~sd(., na.rm = TRUE), median = ~median(., na.rm = TRUE), IQR = ~IQR(., na.rm = TRUE) ), .names = &quot;{.col}_{.fn}&quot;)) %&gt;% # Ensure only statistic columns are being pivoted pivot_longer( cols = -cohort, # Exclude &#39;cohort&#39; from pivoting names_to = c(&quot;variable&quot;, &quot;statistic&quot;), names_sep = &quot;_&quot; ) # lock in the variable order variable_order &lt;- unique(df_summary$variable) df_summary &lt;- df_summary %&gt;% pivot_wider( names_from = statistic, values_from = value, values_fn = list(value = mean) # Aggregate if necessary ) df_summary %&gt;% mutate(variable = factor(variable, levels = variable_order)) %&gt;% arrange(variable, cohort) ## # A tibble: 26 × 6 ## cohort variable mean sd median IQR ## &lt;chr&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 older fam 2859 548. 2859 949 ## 2 younger fam 955 551. 955 954 ## 3 older age 45.4 12.2 42 19 ## 4 younger age 23.5 3.66 23 7 ## 5 older part 1.95 0.224 2 0 ## 6 younger part 1.92 0.299 2 0 ## 7 older wt1 63.8 11.2 62 15 ## 8 younger wt1 60.5 10.3 59 14 ## 9 older wt2 67.0 12.7 66 19 ## 10 younger wt2 64.1 11.6 64 17 ## # ℹ 16 more rows As you can see from the table, the summary statistics are calculated for each cohort across the numeric variables. This provides a quick overview of the central tendencies and variability in the dataset for each cohort. Now, these data are still in wide form, but we can easily convert them to long form if needed. What about descriptive statistics by zygosity and sex? library(tidyverse) # Grouping by &#39;zyg,sex&#39; and calculating summary statistics for each group df_summary &lt;- df_wide %&gt;% group_by(zyg,sex) %&gt;% summarise(across(where(is.numeric), list( mean = ~mean(., na.rm = TRUE), sd = ~sd(., na.rm = TRUE), median = ~median(., na.rm = TRUE), IQR = ~IQR(., na.rm = TRUE) ), .names = &quot;{.col}_{.fn}&quot;)) %&gt;% # Ensure only statistic columns are being pivoted pivot_longer( cols = -c(zyg,sex), # Exclude &#39;zygosity&#39; from pivoting names_to = c(&quot;variable&quot;, &quot;statistic&quot;), names_sep = &quot;_&quot; ) ## `summarise()` has grouped output by &#39;zyg&#39;. You can override using the `.groups` ## argument. # lock in the variable order variable_order &lt;- unique(df_summary$variable) df_summary &lt;- df_summary %&gt;% pivot_wider( names_from = statistic, values_from = value, values_fn = list(value = mean) # Aggregate if necessary ) df_summary %&gt;% mutate(variable = factor(variable, levels = variable_order)) %&gt;% arrange(variable,zyg,sex) ## # A tibble: 65 × 7 ## # Groups: zyg [2] ## zyg sex variable mean sd median IQR ## &lt;chr&gt; &lt;chr&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 DZ F fam 2109. 1029. 2891 2048 ## 2 DZ M fam 2144. 1009. 1370. 2042. ## 3 DZ OS fam 2509. 980. 1852. 1956. ## 4 MZ F fam 1338. 992. 1956. 1956. ## 5 MZ M fam 1750. 1010. 2583 2013 ## 6 DZ F age 35.4 14.3 32 20 ## 7 DZ M age 32.3 13.9 28 16 ## 8 DZ OS age 32.9 13.9 28 17 ## 9 MZ F age 35.7 14.3 32 21 ## 10 MZ M age 34.4 14.1 31 18 ## # ℹ 55 more rows As you can see from the table, the summary statistics are calculated for each zygosity and sex across the numeric variables. "],["wide-form-data-visualization.html", "4 Wide Form Data Visualization 4.1 1. Univariate Distributions 4.2 2. Bivariate Distributions 4.3 3. Correlation Analysis", " 4 Wide Form Data Visualization 4.1 1. Univariate Distributions 4.1.1 Histograms Histograms are a great way to visualize the distribution of a single variable. Here, we will create histograms for the weight of twin 1 and twin 2. 4.1.1.1 Histogram of Weight for Twin 1 ggplot(df_wide, aes(x = wt1)) + geom_histogram(bins = 30, fill = &quot;blue&quot;, color = &quot;black&quot;) + labs(x = &quot;Weight of Twin 1&quot;, y = &quot;Frequency&quot;, title = &quot;Distribution of Weight for Twin 1&quot;) + theme_minimal() 4.1.1.2 Histogram of Weight for Twin 2 by Zygosity ggplot(df_wide, aes(x = wt2)) + geom_histogram(bins = 30, fill = &quot;red&quot;, color = &quot;black&quot;) + labs(x = &quot;Weight of Twin 2&quot;, y = &quot;Frequency&quot;, title = &quot;Distribution of Weight for Twin 2&quot;) + theme_minimal() + facet_wrap(~zyg) 4.1.2 Density Plots Density Plot of Weight for Twin 1 ggplot(df_wide, aes(x = wt1, fill = zyg)) + geom_density(alpha = 0.5) + labs(x = &quot;Weight of Twin 1&quot;, y = &quot;Density&quot;, title = &quot;Density Plot of Weight for Twin 1 by Zygosity&quot;) + scale_fill_viridis_d(option = &quot;viridis&quot;, begin = 0.1, end = 0.85) + theme_minimal() Density Plot of Weight for Twin 2 ggplot(df_wide, aes(x = wt2, fill = zyg)) + geom_density(alpha = 0.5) + labs(x = &quot;Weight of Twin 2&quot;, y = &quot;Density&quot;, title = &quot;Density Plot of Weight for Twin 2 by Zygosity&quot;) + scale_fill_viridis_d(option = &quot;viridis&quot;, begin = 0.1, end = 0.85) + theme_minimal() + facet_wrap(~sex) 4.1.3 Box Plots Box Plot of Weight for Twin 1 ggplot(df_wide, aes(x = zyg, y = wt1, fill = zyg)) + geom_boxplot() + labs(x = &quot;Zygosity&quot;, y = &quot;Weight of Twin 1&quot;, title = &quot;Box Plot of Weight for Twin 1 by Zygosity&quot;) + scale_fill_viridis_d(option = &quot;viridis&quot;, begin = 0.1, end = 0.85) + theme_minimal() Box Plot of Weight for Twin 2 ggplot(df_wide, aes(x = zyg, y = wt2, fill = zyg)) + geom_boxplot() + labs(x = &quot;Zygosity&quot;, y = &quot;Weight of Twin 2&quot;, title = &quot;Box Plot of Weight for Twin 2 by Zygosity&quot;) + scale_fill_viridis_d(option = &quot;viridis&quot;, begin = 0.1, end = 0.85) + theme_minimal() Paired Boxplot of Weights by Zygosity ggplot(df_wide, aes(x = zyg, y = wt1, fill = zyg)) + geom_boxplot() + geom_boxplot(aes(y = wt2), color = &quot;red&quot;, fill = NA) + labs(x = &quot;Zygosity&quot;, y = &quot;Weight&quot;, title = &quot;Paired Boxplot of Weights by Zygosity&quot;) + theme_minimal() 4.2 2. Bivariate Distributions 4.2.1 Scatter # Basic Scatter Plot of weight of Twin 1 vs. weight of Twin 2 p &lt;- ggplot(df_wide, aes(x=wt1, y=wt2, color=zyg)) + geom_point(alpha=.5) + labs(x = &quot;Weight of Twin 1&quot;, y = &quot;Weight of Twin 2&quot;, title = &quot;Scatterplot of weight by Zygosity&quot;) + scale_color_viridis_d(option = &quot;viridis&quot;, begin = 0.1,end=.85) + theme_minimal() p Adding a regression line to the scatter plot. p + geom_smooth(method = &quot;lm&quot;, se = FALSE) ## `geom_smooth()` using formula = &#39;y ~ x&#39; 4.2.2 Marginal Density Plots library(ggplot2) library(ggExtra) # Create marginal density plots for x and y axes p_x &lt;- ggplot(df_wide, aes(x = wt1, fill = zyg)) + geom_density(alpha = 0.5) + theme_minimal() + scale_fill_viridis_d(option = &quot;viridis&quot;, begin = 0.1, end = 0.85) + theme(axis.title.x = element_blank(), axis.text.x = element_blank(), axis.ticks.x = element_blank()) p_x p_y &lt;- ggplot(df_wide, aes(x = wt2, fill = zyg)) + geom_density(alpha = 0.5) + scale_fill_viridis_d(option = &quot;viridis&quot;, begin = 0.1, end = 0.85) + coord_flip() + theme_minimal() + theme(axis.title.y = element_blank(), axis.text.y = element_blank(), axis.ticks.y = element_blank()) p_y # with marginal histogram p1 &lt;- ggMarginal(p, type=&quot;histogram&quot;) p1 # marginal density p2 &lt;- ggMarginal(p, type=&quot;density&quot;) p2 # marginal boxplot p3 &lt;- ggMarginal(p, type=&quot;boxplot&quot;) p3 4.3 3. Correlation Analysis 4.3.1 Correlation Matrix and Correlogram library(ggcorrplot) # select only the variables of interest df_cor &lt;- df_wide %&gt;% select(wt1, wt2, ht1, ht2) # Compute correlation matrix corr &lt;- cor(df_cor ,use=&quot;pairwise.complete&quot;) %&gt;% round(2) ggcorrplot(corr, type = &quot;lower&quot;, lab = TRUE, lab_size = 3, method = &quot;circle&quot;, colors = c(&quot;tomato2&quot;, &quot;white&quot;, &quot;springgreen3&quot;), title = &quot;Correlation Matrix of Twin Data&quot;, ggtheme = theme_bw) 4.3.1.1 By zygosity Making a correlation matrix for each zygosity group is a tad more complicated, but still doable. We can use group_by() and summarise() from dplyr to compute the correlation matrix for each group. Then we can arrange the correlations in a long format and plot them using ggplot2. I’ve placed the MZ twins in the lower triangle and the DZ twins in the upper triangle. # Load necessary libraries library(dplyr) # for data manipulation library(purrr) # for functional programming tools corr_zyg &lt;- df_wide %&gt;% # Group the data by &#39;zyg&#39; group_by(zyg) %&gt;% # Compute the correlation matrix for each group summarise( cor_wt1_wt2 = cor(wt1, wt2, use = &quot;pairwise.complete&quot;), cor_wt1_ht1 = cor(wt1, ht1, use = &quot;pairwise.complete&quot;), cor_wt1_ht2 = cor(wt1, ht2, use = &quot;pairwise.complete&quot;), cor_wt2_ht1 = cor(wt2, ht1, use = &quot;pairwise.complete&quot;), cor_wt2_ht2 = cor(wt2, ht2, use = &quot;pairwise.complete&quot;), cor_ht1_ht2 = cor(ht1, ht2, use = &quot;pairwise.complete&quot;) ) %&gt;% pivot_longer(-zyg, names_to = &quot;pairs&quot;, values_to = &quot;correlation&quot;) %&gt;% unite(&quot;pairs&quot;, pairs, zyg, sep = &quot;_&quot;) %&gt;% pivot_wider(names_from = pairs, values_from = correlation) # Display the results combined_matrix &lt;- matrix(1, nrow = 4, ncol = 4) rownames(combined_matrix) &lt;- colnames(combined_matrix) &lt;- c(&quot;wt1&quot;, &quot;wt2&quot;, &quot;ht1&quot;, &quot;ht2&quot;) # Fill the lower triangle with MZ correlations combined_matrix[lower.tri(combined_matrix)] &lt;- c( corr_zyg$cor_wt1_wt2_MZ, corr_zyg$cor_wt1_ht1_MZ, corr_zyg$cor_wt1_ht2_MZ, corr_zyg$cor_wt2_ht1_MZ, corr_zyg$cor_wt2_ht2_MZ, corr_zyg$cor_ht1_ht2_MZ ) # Fill the upper triangle with DZ correlations combined_matrix[upper.tri(combined_matrix)] &lt;- c( corr_zyg$cor_wt1_wt2_DZ, corr_zyg$cor_wt1_ht1_DZ, corr_zyg$cor_wt1_ht2_DZ, corr_zyg$cor_wt2_ht1_DZ, corr_zyg$cor_wt2_ht2_DZ, corr_zyg$cor_ht1_ht2_DZ ) # Plot the correlation matrix ggcorrplot(combined_matrix, show.diag = TRUE, lab = TRUE, lab_size = 3, method = &quot;circle&quot;, colors = c(&quot;tomato2&quot;, &quot;white&quot;, &quot;springgreen3&quot;), title = &quot;Correlation Matrix of Twin Data by Zygosity&quot;, # subtitle = &quot;MZ correlations in the lower triangle, DZ correlations in the upper triangle&quot;, ggtheme = theme_bw) + labs(caption = &quot;MZ correlations in the lower triangle,\\nDZ correlations in the upper triangle&quot;) "],["long-form-data.html", "5 Long Form Data 5.1 Converting from Wide to Long Form 5.2 Data Structure 5.3 Adding sex and zyg 5.4 Summary Statistics 5.5 Data Visualization", " 5 Long Form Data In contrast to wide form data, long form data, also known as “tidy data,” structures datasets where each row represents a single observation, and each column represents a variable. This format is highly beneficial for statistical modeling and data analysis because it simplifies the application of various data manipulation and analysis functions. As before, we’ll use the twinData dataset from the OpenMx package, but we’ll convert it to long form to illustrate handling and analyzing data in this format. 5.1 Converting from Wide to Long Form library(tidyverse) library(NlsyLinks) library(discord) library(BGmisc) library(OpenMx) library(conflicted) # to handle conflicts conflicted::conflicts_prefer(OpenMx::vech,dplyr::filter) # Resolve conflicts data(twinData) df_long &lt;- twinData %&gt;% select(-age) # Convert wide data to long form df_long &lt;- df_long %&gt;% pivot_longer( cols = matches(&#39;1$|2$&#39;), # Select columns ending in &#39;1&#39; or &#39;2&#39; cols_vary = &quot;slowest&quot;, # Specify that the columns are in the same order for each twin names_to = c(&quot;.value&quot;, &quot;twin&quot;), # Split the column names into variable and twin number names_pattern = &quot;(.*)(1|2)&quot; # Capture the variable and twin number ) 5.2 Data Structure Let’s take a look at the structure of the dataset now that it’s in long form. class(df_long) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; glimpse(df_long) ## Rows: 7,616 ## Columns: 11 ## $ fam &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18… ## $ zyg &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1… ## $ part &lt;int&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2… ## $ cohort &lt;chr&gt; &quot;younger&quot;, &quot;younger&quot;, &quot;younger&quot;, &quot;younger&quot;, &quot;younger&quot;, &quot;young… ## $ zygosity &lt;fct&gt; MZFF, MZFF, MZFF, MZFF, MZFF, MZFF, MZFF, MZFF, MZFF, MZFF, M… ## $ twin &lt;chr&gt; &quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;… ## $ wt &lt;int&gt; 58, 54, 55, 66, 50, 60, 65, 40, 60, 76, 48, 70, 51, 53, 58, 4… ## $ ht &lt;dbl&gt; 1.7000, 1.6299, 1.6499, 1.5698, 1.6099, 1.5999, 1.7500, 1.559… ## $ htwt &lt;dbl&gt; 20.0692, 20.3244, 20.2020, 26.7759, 19.2894, 23.4375, 21.2245… ## $ bmi &lt;dbl&gt; 20.9943, 21.0828, 21.0405, 23.0125, 20.7169, 22.0804, 21.3861… ## $ age &lt;int&gt; 21, 24, 21, 21, 19, 26, 23, 29, 24, 28, 29, 19, 23, 22, 23, 2… The dataset now contains a much larger number of observations, as each twin’s data is represented as a separate row. The zygosity variable indicates the zygosity of the twins, while other variables are split into variable and value pairs, reflecting measurements or characteristics of the twins. 5.3 Adding sex and zyg To facilitate analyses that depend on sex or zygosity type, we’ll add these as new columns derived from zygosity. # Add &#39;sex&#39; and &#39;zyg&#39; columns based on &#39;zygosity&#39; df_long &lt;- df_long %&gt;% mutate(sex = case_when( zygosity %in% c(&quot;MZFF&quot;, &quot;DZFF&quot;) ~ &quot;F&quot;, zygosity %in% c(&quot;MZMM&quot;, &quot;DZMM&quot;) ~ &quot;M&quot;, TRUE ~ &quot;OS&quot; ), zyg = case_when( zygosity %in% c(&quot;MZFF&quot;, &quot;MZMM&quot;) ~ &quot;MZ&quot;, zygosity %in% c(&quot;DZFF&quot;, &quot;DZMM&quot;, &quot;DZOS&quot;) ~ &quot;DZ&quot;, TRUE ~ NA_character_ )) Unfortunately, the data do not contain the information for the gender for each twin, so we will just have to settle for noting that the data is missing. 5.4 Summary Statistics Once again, let’s calculate summary statistics for numeric variables across the full sample. This will provide a quick overview of central tendencies and variability in the dataset. When working with long form data, it is often helpful to start with summarizing by the data structure you already have. In this case, we will calculate summary statistics by specific measurement across all twins. Data Structure and Summary Statistics Examine the transformed data and calculate summary statistics similar to those performed in the wide form. summary_stats_long &lt;- df_long %&gt;% summarise(across(where(is.numeric), list( mean = ~mean(., na.rm = TRUE), sd = ~sd(., na.rm = TRUE), median = ~median(., na.rm = TRUE), min = ~min(., na.rm = TRUE), max = ~max(., na.rm = TRUE), IQR = ~IQR(., na.rm = TRUE) ), .names = &quot;{col}_{fn}&quot;)) %&gt;% pivot_longer( cols = everything(), names_to = c(&quot;variable&quot;, &quot;statistic&quot;), names_sep = &quot;_&quot; ) %&gt;% pivot_wider( names_from = statistic, values_from = value ) summary_stats_long %&gt;% print(n = 15) # to see more rows ## # A tibble: 7 × 7 ## variable mean sd median min max IQR ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 fam 1904. 1099. 1904. 1 3808 1904. ## 2 part 1.93 0.265 2 0 2 0 ## 3 wt 63.9 11.7 62 34 127 16 ## 4 ht 1.68 0.0958 1.68 1.34 1.99 0.150 ## 5 htwt 22.6 3.18 22.2 13.3 46.2 3.83 ## 6 bmi 21.8 0.941 21.7 18.1 26.8 1.20 ## 7 age 34.5 14.2 30 17 88 19 Generate frequency tables for sex and zyg, paralleling the wide form analysis. # Frequency Tables Paralleling the wide form analysis, let us create frequency tables for categorical variables like zygosity and sex. These tables should provide a clear picture of the distribution of these categories within the dataset. In some ways, these calculations are simpler in long form data because each row is already an individual observation. # Counting &#39;zygosity&#39; and calculating percentages zygosity_summary_long &lt;- df_long %&gt;% count(zyg, name = &quot;count&quot;) %&gt;% mutate(percentage = count / sum(count) * 100) %&gt;% rename(category = zyg) %&gt;% # Renaming the column for clarity mutate(variable = &quot;zygosity&quot;) # Adding a descriptor column for the variable # Counting &#39;sex&#39; and calculating percentages sex_summary_long &lt;- df_long %&gt;% count(sex, name = &quot;count&quot;) %&gt;% mutate(percentage = count / sum(count) * 100) %&gt;% rename(category = sex) %&gt;% # Renaming the column for clarity mutate(variable = &quot;sex&quot;) # Adding a descriptor column for the variable # Combining both summaries into a single dataframe combined_summary_long &lt;- bind_rows(zygosity_summary_long, sex_summary_long) %&gt;% select(variable, category, everything()) # Reordering columns for clarity combined_summary_long ## # A tibble: 5 × 4 ## variable category count percentage ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 zygosity DZ 4018 52.8 ## 2 zygosity MZ 3598 47.2 ## 3 sex F 3966 52.1 ## 4 sex M 1838 24.1 ## 5 sex OS 1812 23.8 As you can see, the long form data structure allows for a straightforward calculation of frequency tables for categorical variables. The resulting tables provide a clear picture of the distribution, and it does not differ from the wide form analysis, as long as one remembers to that we’re now looking at individual twins rather than pairs. 5.5 Data Visualization 5.5.1 1. Univariate Distributions Univariate distributions are used to examine the distribution of a single variable within a dataset. They provide insights into the central tendency, variability, and shape of the data distribution. Unlike wide form data, long form data can be directly visualized using ggplot2 without the need for additional data manipulation. 5.5.1.1 Histograms Histograms are useful for visualizing the frequency distribution of a single variable. They help identify the distribution pattern, such as normal distribution, skewness, or the presence of outliers. Histogram of Weight ggplot(df_long, aes(x = wt)) + geom_histogram(bins = 30, fill = &quot;blue&quot;, color = &quot;black&quot;) + labs(x = &quot;Weight&quot;, y = &quot;Frequency&quot;, title = &quot;Distribution of Weights&quot;) + theme_minimal() This histogram shows the distribution of weights across all twins in the dataset. The x-axis represents the weight, while the y-axis shows the frequency of each weight range. 5.5.1.2 Histograms Histograms are useful for visualizing the frequency distribution of a single variable. They help identify the distribution pattern, such as normal distribution, skewness, or the presence of outliers. Histogram of Weight ggplot(df_long, aes(x = wt)) + geom_histogram(bins = 30, fill = &quot;blue&quot;, color = &quot;black&quot;) + labs(x = &quot;Weight&quot;, y = &quot;Frequency&quot;, title = &quot;Distribution of Weights&quot;) + theme_minimal() This histogram shows the distribution of weights across all twins in the dataset. The x-axis represents the weight, while the y-axis shows the frequency of each weight range. Histogram of Weight by Zygosity ggplot(df_long, aes(x = wt, fill = zyg)) + geom_histogram(bins = 30, color = &quot;black&quot;, alpha = 0.5) + labs(x = &quot;Weight&quot;, y = &quot;Frequency&quot;, title = &quot;Distribution of Weights by Zygosity&quot;) + theme_minimal() This histogram shows the distribution of weights by zygosity type. The fill color distinguishes between monozygotic (MZ) and dizygotic (DZ) twins. The x-axis represents the weight, while the y-axis shows the frequency of each weight range. The transparency helps in visualizing the overlap between the two distributions. 5.5.2 Density Plots Density plots provide a smooth representation of the distribution of a variable. They are useful for comparing distributions between groups. Density Plot of Weights by Zygosity ggplot(df_long, aes(x = wt, fill = zyg)) + geom_density(alpha = 0.5) + labs(x = &quot;Weight&quot;, y = &quot;Density&quot;, title = &quot;Density Plot of Weights by Zygosity&quot;) + theme_minimal() This density plot shows the distribution of weights by zygosity type. The fill color distinguishes between monozygotic (MZ) and dizygotic (DZ) twins. The x-axis represents the weight, while the y-axis shows the density of each weight range. The plot provides a smooth representation of the distribution, highlighting the differences between the two zygosity groups. Density Plot of Weights by Sex ggplot(df_long, aes(x = wt, fill = sex)) + geom_density(alpha = 0.5) + labs(x = &quot;Weight&quot;, y = &quot;Density&quot;, title = &quot;Density Plot of Weights by Sex&quot;) + theme_minimal() + facet_wrap(~sex) This density plot shows the weight distributions for male (M) and female (F) twins and OS twins. The plot is faceted by sex to provide a clear comparison between the groups groups. 5.5.2.1 2. Box Plots Box plots are useful for visualizing the distribution of a variable and identifying potential outliers. They display the median, quartiles, and extremes of the data. Box Plot of Weights by Zygosity ggplot(df_long, aes(x = zyg, y = wt, fill = zyg)) + geom_boxplot() + labs(x = &quot;Zygosity&quot;, y = &quot;Weight&quot;, title = &quot;Box Plot of Weights by Zygosity&quot;) + theme_minimal() This box plot shows the distribution of weights by zygosity type. The x-axis represents the zygosity (monozygotic or dizygotic), while the y-axis shows the weight range. The plot displays the median, quartiles, and potential outliers for each zygosity group. Violin Plot of Heights by Zygosity ggplot(df_long, aes(x = zyg, y = ht, fill = zyg)) + geom_violin() + labs(x = &quot;Zygosity&quot;, y = &quot;Height&quot;, title = &quot;Violin Plot of Heights by Zygosity&quot;) + theme_minimal() This violin plot shows the distribution of heights by zygosity type. The x-axis represents the zygosity (monozygotic or dizygotic), while the y-axis shows the height range. The plot provides a smooth representation of the distribution, highlighting the differences between the two zygosity groups. 5.5.3 2. Bivariate Distributions Bivariate distributions are used to examine the relationship between two variables. They help in understanding the correlation and interaction between the variables. 5.5.3.1 Scatter Plots Scatter plots are useful for visualizing the relationship between two continuous variables. They help identify patterns, trends, and potential outliers in the data. Scatter Plot of Height vs. Weight ggplot(df_long, aes(x = wt, y = ht, color = zyg)) + geom_point(alpha = 0.5) + labs(x = &quot;Weight&quot;, y = &quot;Height&quot;, title = &quot;Scatter Plot of Weight vs. Height by Zygosity&quot;) + theme_minimal() + geom_smooth(method = &quot;lm&quot;, se = FALSE) ## `geom_smooth()` using formula = &#39;y ~ x&#39; This scatter plot shows the relationship between weight and height, with points colored by zygosity. A linear regression line is added to highlight the trend in the data. The x-axis represents the weight, while the y-axis shows the height. The plot helps in understanding the correlation between weight and height, as well as the differences between monozygotic and dizygotic twins. 5.5.4 4. Marginal Density Plots Marginal density plots are useful for adding distribution information to scatter plots, providing additional context on the variables’ distributions. Marginal Density Plot of Height vs. Weight library(ggExtra) p &lt;- ggplot(df_long, aes(x = wt, y = ht, color = zyg)) + geom_point(alpha = 0.5) + labs(x = &quot;Weight&quot;, y = &quot;Height&quot;, title = &quot;Scatter Plot of Weight vs. Height by Zygosity&quot;) + theme_minimal() ggMarginal(p, type = &quot;density&quot;) This plot shows a scatter plot of weight vs. height with marginal density plots on the x and y axes, providing additional distribution information. 5.5.5 5. Correlations Correlation matrices and correlograms are useful for visualizing the relationships between multiple variables. They show the strength and direction of correlations between variables. ** Correlation Matrix of Twin Data ** library(ggcorrplot) # Select only the variables of interest df_cor_long &lt;- df_long %&gt;% select(wt, ht) # Compute correlation matrix corr_long &lt;- cor(df_cor_long ,use=&quot;pairwise.complete&quot;) %&gt;% round(2) ggcorrplot(corr_long, type = &quot;lower&quot;, lab = TRUE, lab_size = 3, method = &quot;circle&quot;, colors = c(&quot;tomato2&quot;, &quot;white&quot;, &quot;springgreen3&quot;), title = &quot;Correlation Matrix of Twin Data&quot;, ggtheme = theme_bw) This correlation matrix shows the relationships between weight and height. The values indicate the strength and direction of the correlations, with the color representing the correlation strength. Correlation Matrix by Zygosity corr_zyg_long &lt;- df_long %&gt;% group_by(zyg) %&gt;% summarise( cor_wt_ht = cor(wt, ht, use = &quot;pairwise.complete&quot;) ) %&gt;% pivot_longer(-zyg, names_to = &quot;pairs&quot;, values_to = &quot;correlation&quot;) %&gt;% unite(&quot;pairs&quot;, pairs, zyg, sep = &quot;_&quot;) %&gt;% pivot_wider(names_from = pairs, values_from = correlation) combined_matrix_long &lt;- matrix(1, nrow = 2, ncol = 2) rownames(combined_matrix_long) &lt;- colnames(combined_matrix_long) &lt;- c(&quot;wt&quot;, &quot;ht&quot;) # Fill the lower triangle with MZ correlations combined_matrix_long[lower.tri(combined_matrix_long)] &lt;- c(corr_zyg_long$cor_wt_ht_MZ) # Fill the upper triangle with DZ correlations combined_matrix_long[upper.tri(combined_matrix_long)] &lt;- c(corr_zyg_long$cor_wt_ht_DZ) ggcorrplot(combined_matrix_long, show.diag = TRUE, lab = TRUE, lab_size = 3, method = &quot;circle&quot;, colors = c(&quot;tomato2&quot;, &quot;white&quot;, &quot;springgreen3&quot;), title = &quot;Correlation Matrix of Twin Data by Zygosity&quot;, ggtheme = theme_bw) + labs(caption = &quot;MZ correlations in the lower triangle,\\nDZ correlations in the upper triangle&quot;) This plot shows a correlation matrix separated by zygosity. MZ correlations are displayed in the lower triangle, and DZ correlations are in the upper triangle, allowing for a comparison of correlation strengths between the two groups. "],["long-form-data-plots.html", "6 Long Form Data Plots", " 6 Long Form Data Plots "],["introduction-to-path-diagrams.html", "7 Introduction to Path Diagrams 7.1 Constructing a Simple Path Diagram 7.2 Pre-existing software", " 7 Introduction to Path Diagrams Path diagrams are a graphical representation of a structural equation model. They are a useful tool for understanding the relationships between variables in a model, as well as a way to communicate the model to others. In this chapter, we will learn how to create path diagrams using dot notation, as well as explore several software tools available for creating path diagrams, such as DiagrammeR, OpenMx, and umx in R. 7.1 Constructing a Simple Path Diagram To better understand path diagrams, let’s manually construct a simple example. Consider a model where one latent variable influences two observed variables. We can represent this model using the following dot notation: 7.1.1 Understanding the Components Nodes: Represent variables, which can be observed or latent. Nodes are usually depicted as circles (latent variables) or squares (observed variables). Edges: Represent the causal relationships or correlations between variables. An arrow from one node to another indicates a directional relationship, whereas a two-headed arrow indicates a correlation. 7.1.2 Step-by-Step Construction Define the Nodes: Start by defining your nodes, which represent the variables. Here, we have one latent variable and two observed variables. Draw the Edges: Next, draw edges to represent the relationships. In this case, the latent variable influences both observed variables. 7.1.2.1 Example Diagram Let’s put these components together using the DiagrammeR package to: library(DiagrammeR) grViz(&quot; digraph simple_model { node [fontname = Ariel, fontsize = 10] Latent [shape = circle, label = &#39;Latent Variable L&#39;] Obs1 [shape = box, label = &#39;Observed Variable 1&#39;] Obs2 [shape = box, label = &#39;Observed Variable 2&#39;] Latent -&gt; Obs1 Latent -&gt; Obs2 } &quot;) This script uses the DiagrammeR package to manually create a path diagram where ‘Latent Variable L’ influences ‘Observed Variable 1’ and ‘Observed Variable 2’. The arrows indicate the direction of influence from the latent to the observed variables. 7.1.3 ACE Model Example Here is a more complex example of a path diagram for a univariate ACE model using dot notation and the DiagrammeR package in R. library(DiagrammeR) grViz(&#39;digraph &quot;Univariate ACE Model&quot; { node [style=filled, fontname=&quot;Arial&quot;, fontsize=16]; /* Observed Trait */ Trait [shape=square, fillcolor=&quot;#a9fab1&quot;, height=0.5, width=0.5, label=&quot;Trait&quot;]; /* Latent Variables */ A [shape=circle, fillcolor=&quot;#f4fd78&quot;, label=&quot;A&quot;]; C [shape=circle, fillcolor=&quot;#f4fd78&quot;, label=&quot;C&quot;]; E [shape=circle, fillcolor=&quot;#f4fd78&quot;, label=&quot;E&quot;]; /* Paths from Latent Variables to Observed Trait */ A -&gt; Trait [dir=forward]; C -&gt; Trait [dir=forward]; E -&gt; Trait [dir=forward]; /* Variance Paths for Latent Variables */ A -&gt; A [dir=both, headport=n, tailport=n]; C -&gt; C [dir=both, headport=n, tailport=n]; E -&gt; E [dir=both, headport=n, tailport=n]; }&#39; ) Below is an explanation of the code snippet: Latent Variables: A [shape=circle, fillcolor=\"#f4fd78\", label=\"A\"];: Defines the latent variable A (Additive genetic factors) with a circular shape, yellow color (#f4fd78), and the label “A”. C [shape=circle, fillcolor=\"#f4fd78\", label=\"C\"];: Defines the latent variable C (Common/shared environmental factors) with a circular shape, yellow color, and the label “C”. E [shape=circle, fillcolor=\"#f4fd78\", label=\"E\"];: Defines the latent variable E (Unique environmental factors) with a circular shape, yellow color, and the label “E”. Paths from Latent Variables to Observed Trait: A -&gt; Trait [dir=forward];: Creates a forward directional path from the latent variable A to the observed trait. C -&gt; Trait [dir=forward];: Creates a forward directional path from the latent variable C to the observed trait. E -&gt; Trait [dir=forward];: Creates a forward directional path from the latent variable E to the observed trait. Variance Paths for Latent Variables: A -&gt; A [dir=both, headport=n, tailport=n];: Represents the variance of the latent variable A with a bidirectional path. C -&gt; C [dir=both, headport=n, tailport=n];: Represents the variance of the latent variable C with a bidirectional path. E -&gt; E [dir=both, headport=n, tailport=n];: Represents the variance of the latent variable E with a bidirectional path. The resulting path diagram visualizes the relationships between the latent variables (A, C, E) and the observed trait in an ACE model. 7.2 Pre-existing software There are several existing software tools that can be used to create path diagrams for specific models, such as the umx and OpenMx packages in R. These tools provide a user-friendly interface for creating and visualizing path diagrams, making it easier to understand and communicate complex models. 7.2.1 Creating a Path Diagram with omxGraphviz library(OpenMx) data(demoOneFactor) manifests &lt;- names(demoOneFactor) latents &lt;- c(&quot;G1&quot;) model1 &lt;- mxModel(&quot;One Factor&quot;, type=&quot;RAM&quot;, manifestVars = manifests, latentVars = latents, mxPath(from=latents, to=manifests), mxPath(from=manifests, arrows=2), mxPath(from=latents, arrows=2, free=F, values=1.0), mxData(cov(demoOneFactor), type=&quot;cov&quot;,numObs=500) ) omxGraphviz(model1, &quot;one-factor-generated.dot&quot;) The following code snippet creates a path diagram for a one-factor model using the OpenMx package. The model includes one latent variable (G1) and three manifest variables (x1, x2, x3). The mxModel function is used to define the model, and the mxPath function is used to specify the paths between variables. The mxData function is used to specify the data for the model. Finally, the omxGraphviz function is used to generate a graphical representation of the model in the form of a dot file. I have annotated the dot file to explain the purpose of each function and argument. The resulting dot file can be visualized using graph visualization tools like Graphviz or packages like DiagrammeR. digraph &quot;One Factor&quot; { // Setting the style and font for all nodes node [style=filled, fontname=&quot;Arial&quot;, fontsize=16]; /* Manifest Variables */ // Grouping all manifest variables (x1 to x5) to be on the same rank (horizontal alignment) { rank = max; x1; x2; x3; x4; x5 } // Defining each manifest variable with square shape, color, and size x1 [shape=square, fillcolor=&quot;#a9fab1&quot;, height=0.5, width=0.5]; x2 [shape=square, fillcolor=&quot;#a9fab1&quot;, height=0.5, width=0.5]; x3 [shape=square, fillcolor=&quot;#a9fab1&quot;, height=0.5, width=0.5]; x4 [shape=square, fillcolor=&quot;#a9fab1&quot;, height=0.5, width=0.5]; x5 [shape=square, fillcolor=&quot;#a9fab1&quot;, height=0.5, width=0.5]; /* Latent Variables */ // Defining the latent variable G1 with a circular shape and color G1 [shape=circle, fillcolor=&quot;#f4fd78&quot;]; /* Paths */ // Defining directional paths from the latent variable G1 to each manifest variable G1 -&gt; x1[dir=forward]; G1 -&gt; x2[dir=forward]; G1 -&gt; x3[dir=forward]; G1 -&gt; x4[dir=forward]; G1 -&gt; x5[dir=forward]; // Defining bidirectional paths for each manifest variable to represent error terms x1 -&gt; x1[dir=both, headport=s, tailport=s]; x2 -&gt; x2[dir=both, headport=s, tailport=s]; x3 -&gt; x3[dir=both, headport=s, tailport=s]; x4 -&gt; x4[dir=both, headport=s, tailport=s]; x5 -&gt; x5[dir=both, headport=s, tailport=s]; // Defining a bidirectional path for the latent variable G1 to represent its variance G1 -&gt; G1[dir=both, headport=n, tailport=n]; } We can load the dot file into R and visualize the path diagram using the DiagrammeR package. library(DiagrammeR) grViz(&quot;one-factor-generated.dot&quot;) The resulting path diagram shows the relationships between the latent variable G1 and the manifest variables x1, x2, x3, x4, and x5. The directional paths from G1 to the manifest variables represent the factor loadings, while the bidirectional paths for each manifest variable represent the error terms. The bidirectional path for the latent variable G1 represents its variance. 7.2.2 Creating a Path Diagram for an ACE Model Using the umx Package The umx package provides a user-friendly interface for specifying and estimating structural equation models, including path diagrams for classical models like the ACE model in twin studies. The umx package simplifies the process of specifying and estimating complex structural equation models like the ACE model. Below is an example of how to create a path diagram for an ACE model using the umx package in R. (Many thanks to Tim Bates for providing the source code). library(umx) #&gt; For an overview type &#39;?umx&#39; #&gt; #&gt; Attaching package: &#39;umx&#39; #&gt; The following object is masked from &#39;package:stats&#39;: #&gt; #&gt; loadings library(tidyverse) # Thanks to Tim Bates for making some nice tidy Source Code # ===================== # = Make an ACE model = # ===================== # 1. Clean data: Add separator and scale data(twinData) tmp &lt;- umx_make_twin_data_nice(data=twinData, sep=&quot;&quot;, zygosity=&quot;zygosity&quot;, numbering=1:2) %&gt;% umx_scale_wide_twin_data(varsToScale= c(&quot;wt&quot;, &quot;ht&quot;), sep= &quot;_T&quot;, data= .) mzData &lt;- subset(tmp, zygosity %in% c(&quot;MZFF&quot;, &quot;MZMM&quot;)) dzData &lt;- subset(tmp, zygosity %in% c(&quot;DZFF&quot;, &quot;DZMM&quot;)) # 2. Define paths: You only need the paths for one person: paths &lt;- c( umxPath(v1m0 = c(&quot;a1&quot;, &#39;c1&#39;, &quot;e1&quot;)), umxPath(means = c(&quot;wt&quot;)), umxPath(c(&quot;a1&quot;, &#39;c1&#39;, &quot;e1&quot;), to = &quot;wt&quot;, values=.2) ) m1 &lt;- umxTwinMaker(&quot;test&quot;, paths, mzData = mzData, dzData = dzData) #&gt; 6 latent variables were created:a1_T1, c1_T1, e1_T1, a1_T2, c1_T2, e1_T2. #&gt; 6 latent variables were created:a1_T1, c1_T1, e1_T1, a1_T2, c1_T2, e1_T2. #&gt; Running test with 4 parameters #&gt; ?umxSummary options: std=T|F&#39;, digits=, report= &#39;html&#39;, filter= &#39;NS&#39; &amp; more #&gt; Running Saturated test with 10 parameters #&gt; Running Independence test with 8 parameters #&gt; #&gt; #&gt; Table: (\\#tab:unnamed-chunk-5)Parameter loadings for model &#39;test&#39; #&gt; #&gt; | |name | Estimate|SE |type | #&gt; |:--|:----------------|--------:|:-----|:---------------| #&gt; |8 |a1_T1_MZr_a1_T2 | 1.000|0 |Factor Cov | #&gt; |10 |c1_T1_MZr_c1_T2 | 1.000|0 |Factor Cov | #&gt; |24 |a1_T1_DZr_a1_T2 | 0.500|0 |Factor Cov | #&gt; |26 |c1_T1_DZr_c1_T2 | 1.000|0 |Factor Cov | #&gt; |1 |a1_to_wt | 0.773|0.025 |Factor loading | #&gt; |2 |c1_to_wt | 0.461|0.043 |Factor loading | #&gt; |3 |e1_to_wt | 0.378|0.006 |Factor loading | #&gt; |7 |a1_T1_with_a1_T1 | 1.000|0 |Factor Variance | #&gt; |9 |c1_T1_with_c1_T1 | 1.000|0 |Factor Variance | #&gt; |11 |e1_T1_with_e1_T1 | 1.000|0 |Factor Variance | #&gt; |12 |a1_T2_with_a1_T2 | 1.000|0 |Factor Variance | #&gt; |13 |c1_T2_with_c1_T2 | 1.000|0 |Factor Variance | #&gt; |14 |e1_T2_with_e1_T2 | 1.000|0 |Factor Variance | #&gt; |15 |one_to_wt | -0.065|0.017 |Mean | #&gt; #&gt; Model Fit: χ²(6) = 8.64, p = 0.195; CFI = 0.999; TLI = 1; RMSEA = 0.012 plot(m1, std= TRUE, means= FALSE) #&gt; #&gt; ?plot.MxModel options: std, means, digits, strip_zero, file, splines=T/F, min=, max =, same = , fixed, resid= &#39;circle|line|none&#39; The resulting path diagram shows the relationships between the latent variables A, C, and E and the manifest variable wt. The paths between the latent variables and manifest variables represent the factor loadings, while the bidirectional paths for each manifest variable represent the error terms. The bidirectional path for each latent variable represents its variance. This diagram only shows the paths for one twin, but the model is estimated using data from multiple twin pairs to estimate the genetic, shared environmental, and non-shared environmental influences on the trait. "],["generating-tables-in-apa-style.html", "8 Generating Tables in APA Style 8.1 Summary Statistics 8.2 Frequency Tables", " 8 Generating Tables in APA Style When presenting data in scientific papers, it’s important to follow the guidelines provided by the American Psychological Association (APA) to ensure clarity and consistency. In this section, we’ll demonstrate how to generate tables in APA style using the kableExtra package in R. 8.1 Summary Statistics First, let’s calculate summary statistics for the twin data and present them in an APA-style table. # Load necessary libraries library(tidyverse) ## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ── ## ✔ dplyr 1.1.4 ✔ readr 2.1.5 ## ✔ forcats 1.0.0 ✔ stringr 1.5.1 ## ✔ ggplot2 3.5.1 ✔ tibble 3.2.1 ## ✔ lubridate 1.9.3 ✔ tidyr 1.3.1 ## ✔ purrr 1.0.2 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() ## ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors library(kableExtra) ## ## Attaching package: &#39;kableExtra&#39; ## ## The following object is masked from &#39;package:dplyr&#39;: ## ## group_rows library(tidyverse) library(NlsyLinks) library(discord) library(BGmisc) library(OpenMx) ## ## Attaching package: &#39;OpenMx&#39; ## ## The following object is masked from &#39;package:BGmisc&#39;: ## ## vech library(conflicted) # to handle conflicts conflicted::conflicts_prefer(OpenMx::vech,dplyr::filter) # Resolve conflicts ## [conflicted] Will prefer OpenMx::vech over any other package. ## [conflicted] Will prefer dplyr::filter over any other package. data(twinData) df_long &lt;- twinData %&gt;% select(-age) # Convert wide data to long form df_long &lt;- df_long %&gt;% pivot_longer( cols = matches(&#39;1$|2$&#39;), # Select columns ending in &#39;1&#39; or &#39;2&#39; cols_vary = &quot;slowest&quot;, # Specify that the columns are in the same order for each twin names_to = c(&quot;.value&quot;, &quot;twin&quot;), # Split the column names into variable and twin number names_pattern = &quot;(.*)(1|2)&quot; # Capture the variable and twin number ) # Add &#39;sex&#39; and &#39;zyg&#39; columns based on &#39;zygosity&#39; df_long &lt;- df_long %&gt;% mutate(sex = case_when( zygosity %in% c(&quot;MZFF&quot;, &quot;DZFF&quot;) ~ &quot;F&quot;, zygosity %in% c(&quot;MZMM&quot;, &quot;DZMM&quot;) ~ &quot;M&quot;, TRUE ~ &quot;OS&quot; ), zyg = case_when( zygosity %in% c(&quot;MZFF&quot;, &quot;MZMM&quot;) ~ &quot;MZ&quot;, zygosity %in% c(&quot;DZFF&quot;, &quot;DZMM&quot;, &quot;DZOS&quot;) ~ &quot;DZ&quot;, TRUE ~ NA_character_ )) # Calculate summary statistics summary_stats_long &lt;- df_long %&gt;% summarise(across(where(is.numeric), list( Mean = ~mean(., na.rm = TRUE), SD = ~sd(., na.rm = TRUE), Median = ~median(., na.rm = TRUE), Min = ~min(., na.rm = TRUE), Max = ~max(., na.rm = TRUE), IQR = ~IQR(., na.rm = TRUE) ), .names = &quot;{col}_{fn}&quot;)) %&gt;% pivot_longer( cols = everything(), names_to = c(&quot;Variable&quot;, &quot;Statistic&quot;), names_sep = &quot;_&quot; ) %&gt;% pivot_wider( names_from = Statistic, values_from = value ) Now, let’s create an APA-style table for these summary statistics. # Generate APA-style table summary_stats_long %&gt;% kable(caption = &quot;Summary Statistics for Twin Data&quot;, col.names = c(&quot;Variable&quot;, &quot;Mean&quot;, &quot;SD&quot;, &quot;Median&quot;, &quot;Min&quot;, &quot;Max&quot;, &quot;IQR&quot;), format = &quot;html&quot;) %&gt;% kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;, &quot;condensed&quot;, &quot;responsive&quot;), full_width = FALSE, position = &quot;left&quot;) %&gt;% add_header_above(c(&quot; &quot; = 1, &quot;Summary Statistics&quot; = 6)) %&gt;% footnote(general = &quot;Note. This table presents the summary statistics for the variables in the twin dataset.&quot;, general_title = &quot; &quot;, footnote_as_chunk = TRUE) Table 8.1: Summary Statistics for Twin Data Summary Statistics Variable Mean SD Median Min Max IQR fam 1904.500000 1099.3470505 1904.5000 1.0000 3808.0000 1903.5000 part 1.933298 0.2648394 2.0000 0.0000 2.0000 0.0000 wt 63.881744 11.7100387 62.0000 34.0000 127.0000 16.0000 ht 1.677868 0.0958175 1.6799 1.3398 1.9900 0.1501 htwt 22.612309 3.1794125 22.2041 13.2964 46.2493 3.8303 bmi 21.764600 0.9408264 21.7019 18.1125 26.8383 1.2029 age 34.453494 14.1704368 30.0000 17.0000 88.0000 19.0000 Note. This table presents the summary statistics for the variables in the twin dataset. The table above presents the summary statistics for the variables in the twin dataset, including the mean, standard deviation, median, minimum, maximum, and interquartile range. 8.2 Frequency Tables Next, we’ll create frequency tables for categorical variables such as zygosity and sex, and format them in APA style. # Calculate frequency tables frequency_tables &lt;- df_long %&gt;% select(zyg, sex) %&gt;% pivot_longer(cols = everything(), names_to = &quot;Variable&quot;, values_to = &quot;Category&quot;) %&gt;% group_by(Variable, Category) %&gt;% summarise(Count = n()) %&gt;% mutate(Percentage = round((Count / sum(Count)) * 100, 2)) %&gt;% ungroup() ## `summarise()` has grouped output by &#39;Variable&#39;. You can override using the ## `.groups` argument. Let’s create an APA-style table for these frequency tables. "],["generate-apa-style-table-for-frequency-tables.html", "9 Generate APA-style table for frequency tables", " 9 Generate APA-style table for frequency tables frequency_tables %&gt;% kable(caption = &quot;Frequency Tables for Categorical Variables&quot;, col.names = c(&quot;Variable&quot;, &quot;Category&quot;, &quot;Count&quot;, &quot;Percentage&quot;), format = &quot;html&quot;) %&gt;% kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;, &quot;condensed&quot;, &quot;responsive&quot;), full_width = FALSE, position = &quot;left&quot;) %&gt;% add_header_above(c(&quot; &quot; = 2, &quot;Frequency Table&quot; = 2)) %&gt;% footnote(general = &quot;Note. This table presents the frequency and percentage of categories for zygosity and sex in the twin dataset.&quot;, general_title = &quot; &quot;, footnote_as_chunk = TRUE) Table 9.1: Frequency Tables for Categorical Variables Frequency Table Variable Category Count Percentage sex F 3966 52.07 sex M 1838 24.13 sex OS 1812 23.79 zyg DZ 4018 52.76 zyg MZ 3598 47.24 Note. This table presents the frequency and percentage of categories for zygosity and sex in the twin dataset. "],["final-words.html", "10 Final Words", " 10 Final Words Throughout this document, we have embarked on an exploration of the evolving landscape of data visualization in the field of behavior genetics. By revisiting historical methodologies and embracing modern techniques, we have uncovered a rich tapestry of visual tools that enhance our understanding and communication of genetic data. The atlas of ggplot2 visualizations presented here not only serves as a practical guide but also as an inspiration for researchers to think creatively about how data can be visualized more effectively. "],["references.html", "References", " References Wright, S. 1920. “The Relative Importance of Heredity and Environment in Determining the Piebald Pattern of Guinea-Pigs.” Proceedings of the National Academy of Sciences 6 (6): 320–32. https://doi.org/10.1073/pnas.6.6.320. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
